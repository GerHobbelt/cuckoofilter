\documentclass[11pt,letterpaper]{article}
%\usepackage{amsfonts}
%\usepackage{amssymb}
\usepackage[margin=0.75in, bottom=1.25in]{geometry}
\usepackage[T1]{fontenc}
\usepackage[bitstream-charter]{mathdesign}
\usepackage{cite}

\begin{document}
\title{Tail Filters}
\author{Jim Apple}
\maketitle

\section{Introduction}

We will discuss {\em approximate membership query} (or {\em ``AMQ''}) data structures.
An instance of an AMQ is an over-approximation of a set $S$, and is equipped with a {\bf lookup} operation that returns {\bf true} for any key in $S$ and {\bf false} with high probability for any key not in $S$.

\section{Notation}

If not otherwise specified, $U$ is a finite universe of keys, $F$ is an AMQ, $x \in U$ is a key, $s$ is a bitstring, $m$, $n$, and $i$ are non-negative integers, and $0 < \epsilon < 1$.
The size of a set $Y$ is denoted ``$|Y|$''; the length of a bitstring $s$ is also denoted $|s|$.
The binary logarithm $\log_2$ is denoted ``$\lg$''.
$\lfloor r \rfloor$ is the largest integer less than or equal to $r$.
%$\widehat{n}$ is $\{0, 1, \dots , 2^n - 1\}$, which is isomorphic with the set of bitstrings of length $n$.

Any function $f: P \to Q$ can be extended to a function from subsets of $P$ to subsets of $Q$ by $f(P) \triangleq \{ q \in Q: \exists p \in P, f(p) = q\}$.

$[n]$ denotes $\{0, 1, \dots n - 1 \}$.
Note that $[2^n]$ is trivially isomorphic to bitstrings of length $n$.
In an abuse of notation, when $n$ is implicit, values in $[2^n]$ and their equivalent bitstrings will be interchangable.
Similarly, ``$[2^n]$'' will sometimes denote the set of bitstrings of length $n$, rather than $\{0, 1, \dots, 2^n - 1\}$.

%% ; we'll call this isomorphism $v$.
%% The set of bitstrings of length $n$ can thus be denoted ``$v^{-1}[2^n]$''.
%% In an abuse of notation, $v^{-1}[2^n]$ will sometimes be denoted simply ``$[2^n]$''.

%% There also exists an injection, $w$, from the set of bitstrings $\cup_{i \in [n]} [2^i]$ to $[2^n]$ by $w(m \in [2^i]) = v(2^i + v^{-1}(m))$.
%% This representation is not surjective due to a single value of $[2^n]$ that has no pre-image: the bitstring consisting of all zeros

The set of bitstrings of length less than $n$,  $\bigcup_{i < n} [2^i]$, is isomorphic to $[2^n]$ via $(m \in [2^i]) \mapsto 2^i + m$.
This representation is not surjective due to a single value of $[2^n]$ that has no pre-image: $0$.
This value can be repurposed so that any value in $[2^n]$ can be thought of either as being absent or a bitstring of length less than $n$.

Each AMQ $F$ represents a subset of $U$.
The subset of $U$ represented by a structure $F$ is denoted $[F]$.
The size of the subset relative to the whole universe, $|[F]|/|U|$, is called the {\em false positive probability}, or {\em ``fpp''}.

The AMQ's discussed here support at least the following three operations:

\begin{description}
\item[initialize$(m, \epsilon)$] creates a structure.
  $m$ is the initial pre-allocated space of the data structure, such that $m$ calls to {\bf insert} can be made before more space needs to be allocated;
  $\epsilon$ is the initial fpp maximum, such that $m$ calls to {\bf insert} can be made before the fpp exceeds $\epsilon$.
  %% Up to $m$ keys can be {\bf insert}ed.
  %% $m$ is called the {\em capacity} of $F$.
  %% $\epsilon$ is called the {\em false positive probability}, or ``{\em fpp}''.
\item[insert$(x)$] adds the key $x$ to $F$ such that $x \in [F]$.
  It might increase the fpp or the space usage of $F$, or both.
\item[lookup$(x)$] returns {\bf true} if $x \in [F]$.
  Note that if $x \in [F]$, it need not have been inserted, since $[F]$ is an over-approximation of the set of insert keys.
%  Note that $\epsilon \geq (|[F]| - n)/|U|)$.
% \item[upsize] doubles the capacity of $F$; it may increase the fpp.
\end{description}

Using low-overhead dictionaries like the one described below, any subset of $U$ of size $n$ can be stored exactly (i.e. with fpp $n/U$) in $O(n \lg (|U|/n))$.
As such, we'll assume all calls to {\bf initialize} have $\epsilon > 1/|U|$.

Each key in the universe $U$ is associated with a bitstring of length $\lceil 2 \lg |U| \rceil$.
%; this is commonly done through hashing.
 % $\lg |U| - \lg \epsilon + c_1$, for some constant $c_1$ to be specified later.
For the remainder of the paper, we will assume that the keys inserted have random values.
This is frequently done by considering operations on the set $h(U)$, where $h$ is a suitable hash function, rather than $U$.
For the rest of this paper, the universe $F$ is over will actually be $h(U)$, though we will refer to it as $U$, as we have no more need for the original ``$U$''.

The main challenge of this work is to keep all of the following low:

\begin{enumerate}
\item The fpp of $F$
\item The number of bits needed to store $F$
\item The time complexities of {\bf insert} and {\bf lookup}
\end{enumerate}

\section{Practical quotienting dictionaries with continual minimal overhead}

[Combination of cuckoo filters, the A-B design of shingle filters or the journal version of Morton filters, and DySECT]

\section{The tail filter}

The {\em tail filter} is based on the design of the filter in Pagh et al.~\cite{DBLP:journals/corr/abs-1304-1188}

In this section, we'll first describe the abstract semantics of tail filters, using this to show their fpp.
This semantics will equate a tail filter with a set of bitstrings of varying lengths.
After that, we'll describe a mechanism for storing the bitstrings associated with a tail filter in a way that has low space usage and operation time complexity.

\subsection{The abstract semantics of tail filters}

An abstract tail filter $F$ consists of a positive integer $m$, a real number $0 < \epsilon < 1$, and a set of bitstrings of varying lengths. %, and its fpp increases as it grows.
The subset of $U$ it represents, $[F]$ is defined as $\{x \in U : \exists y \in F, y \textrm{ is a prefix of } x\}$.
%{\bf lookup$(x)$} is defined to return {\bf true} if any of the bitstrings in $F$ is a prefix of $x$.
If any bitstring $x$ in $F$ is a prefix of another bitstring $y$ in $F$, $y$ can be removed from $F$ without changing $[F]$, so wlog, we can assume $F$ is {\em ''prefix-free''}: no bitstring in $F$ is a prefix of any other bitstring in $F$.

% TODO: what about removing bitstrings when a shorter one is inserted? Good news: we only ever insert longer ones

Abstract tail filters have restrictions on the number of strings of each length.
Let $n$ be the number of bitstrings in $F$.
The shortest bitstring has length $\lfloor \lg (m / \epsilon) \rfloor$ and the longest has length $\lfloor \lg (n/m) \rfloor + \lfloor \lg (m / \epsilon) \rfloor$.
This last value is guaranteed to be less than $\lceil 2 \lg |U| \rceil$, since $\epsilon > 1/|U|$.

\begin {itemize}
\item $m$ bitstrings have length $\lfloor \lg (m / \epsilon) \rfloor$
\item For each $0 < j < \lfloor \lg (n/m) \rfloor $, $m2^{j-1}$ bitstrings have length $j + \lfloor \lg (m / \epsilon) \rfloor$.
\item $n - m2^{\lfloor \lg (n/m) \rfloor}$ bitstrings have length $1 + \lfloor \lg (n/m) \rfloor  + \lfloor \lg (m / \epsilon) \rfloor$.
\end {itemize}

The items with a length $j + \lfloor \lg (m / \epsilon) \rfloor$ are said to be in {\em ``cohort''} $j$.
Each bitstring in cohort $j$ adds $2^{- j - \lfloor \lg (m / \epsilon) \rfloor}$ to the fpp, so the full cohort adds $m2^{- \lfloor \lg (m / \epsilon) \rfloor}$ to the fpp.
Each additional cohort $j$, excluding $j = \lfloor \lg (n/m) \rfloor$, adds $m 2^{j-1} 2^{-j - \lfloor \lg (m / \epsilon) \rfloor} = (m/2) 2^{-\lfloor \lg (m / \epsilon) \rfloor}$ to the fpp.
The last cohort adds less than or equal to $(m/2) 2^{-\lfloor \lg (m / \epsilon) \rfloor}$, since $n - m 2^{\lfloor \lg (n/m) \rfloor} \leq m 2^{\lfloor \lg(n/m)\rfloor}$.
The sum total fpp is $m 2^{- \lfloor \lg (m / \epsilon) \rfloor} (1 + \lfloor \lg (n/m) \rfloor)$, which is less than

\begin{equation}
  2 \epsilon (1 + \lfloor \lg (n/m) \rfloor)
\end{equation}

%% For the last epoch, let $\alpha \triangleq \lg (n/m) - \lfloor \lg (n/m) \rfloor$.
%% Then the last epoch has $n - m 2^{\lg (n/m) - \alpha} = n (1 - 2^{-\alpha})$ bitstrings of length $1 + \lg (n/m) - \alpha + \lfloor \lg (m / \epsilon) \rfloor$.
%% These contribute $(m/2) (2^{\alpha} - 1) 2^{ - \lfloor \lg (m / \epsilon) \rfloor}$ to the fpp.
%% Since this is less than or equal to $(m/2) 2^{-\lfloor \lg (m / \epsilon) \rfloor}$, the total fpp is less than or equal to

%% $$m 2^{- \lfloor \lg (m / \epsilon) \rfloor} (1 + \lfloor \lg (n/m) \rfloor)$$

%% which is less than 

%% $$2^{\lg m - (\lg (m / \epsilon) - 1)} (1 + \lfloor \lg (n/m) \rfloor)$$
%% $$2^{\lg \epsilon + 1} (1 + \lfloor \lg (n/m) \rfloor)$$

%% $$n (1 - 2^{-\alpha}) 2^{-\lg (n/m) + \alpha - \lfloor \lg (m / \epsilon) \rfloor}$$
%% $$n (1 - 2^{-\alpha}) (m/n) 2^{\alpha} 2^{ - \lfloor \lg (m / \epsilon) \rfloor}$$
%% $$m (2^{\alpha} - 1) 2^{ - \lfloor \lg (m / \epsilon) \rfloor} $$
%% $$m (2^{\lg (n/m) - \lfloor \lg (n/m) \rfloor} - 1) 2^{ - \lfloor \lg (m / \epsilon) \rfloor} $$
%% $$m (2^{\lg (n/m) - \lfloor \lg (n/m) \rfloor} - 1) 2^{ - \lfloor \lg (m / \epsilon) \rfloor} $$

%% $$n - m 2^{\lfloor \lg (n/m) \rfloor} ? m 2^{\lfloor \lg(n/m)\rfloor}$$
%% $$n ? m 2^{1 + \lfloor \lg(n/m)\rfloor}$$
%% $$m 2^{\lg (n/m)} ? m 2^{1 + \lfloor \lg(n/m)\rfloor}$$
%% $$\lg (n/m) ? 1 + \lfloor \lg(n/m)\rfloor$$

%% The last epoch is epoch $\lfloor \lg (n/m) \rfloor$, so the total fpp is less than or equal to

%% $$m2^{- \min (\lg |U|, \lfloor \lg (m / \epsilon) \rfloor)} + (m/2) \sum_{j=1}^{\lfloor \lg (n/m) \rfloor} 2^{-\min(\lg |U| - j, \lfloor \lg (m / \epsilon) \rfloor)}$$

%% If $|U| \geq  n/\epsilon$, then $\lg |U| \geq  \lfloor \lg (n/m) \rfloor + \lfloor \lg(m/\epsilon) \rfloor$, so the fpp is $m (1 + \lfloor \lg (n/m) \rfloor / 2) 2^{- \lfloor \lg (m / \epsilon) \rfloor}$.
%% $2^{- \lfloor \lg (m / \epsilon) \rfloor} < 2 (\epsilon / m)$, so the total fpp is less than $\epsilon (2 + \lfloor \lg (n/m) \rfloor)$.
%% This matches or improves the result of Pagh et al. when $2 + \lfloor \lg (n/m) \rfloor \in \lg^{O(1)} |U|$.


%% Tail filters additionally store a count of the number of {\bf insert} operations performed so far, as well as $m$ and $\epsilon$ from their {\bf initialize} operation.
%% The {\bf insert} count is used to define {\em ``epochs''}.
%% An epoch consists of a temporally contiguous set of {\bf insert} calls.
%% Epoch 0 consists of the first $m$ {\bf insert}s.
%% Epoch $i+1$ consists of the $2^i m$ {\bf insert}s after epoch $i$.

%% Epochs have an important operational manifestation during {\bf insert}: all bitstrings {\bf insert}ed into a tail filter during epoch $j$ have length $\min (\lg |U|, j + \lfloor \lg (m / \epsilon) \rfloor)$.

%% The fpp of a tail filter can be calculated as follows:

%% Each {\bf insert} in epoch $j$ adds $2^{-\min (\lg |U|, j + \lfloor \lg (m / \epsilon) \rfloor)}$ to the fpp.
%% The structure starts with an fpp of $0$.
%% By the end of epoch $0$, its fpp is less than or equal to $m2^{- \min (\lg |U|, \lfloor \lg (m / \epsilon) \rfloor)}$. % < 2 \epsilon$.
%% Each additional full epoch $j$ adds $m 2^{j-1} 2^{-\min(\lg |U|, j + \lfloor \lg (m / \epsilon) \rfloor)} = (1/2) m 2^{-\min(\lg |U| - j, \lfloor \lg (m / \epsilon) \rfloor)}$ to the fpp.

%% The last epoch is epoch $\lfloor \lg (n/m) \rfloor$, so the total fpp is less than or equal to

%% $$m2^{- \min (\lg |U|, \lfloor \lg (m / \epsilon) \rfloor)} + (m/2) \sum_{j=1}^{\lfloor \lg (n/m) \rfloor} 2^{-\min(\lg |U| - j, \lfloor \lg (m / \epsilon) \rfloor)}$$

%% If $|U| \geq  n/\epsilon$, then $\lg |U| \geq  \lfloor \lg (n/m) \rfloor + \lfloor \lg(m/\epsilon) \rfloor$, so the fpp is $m (1 + \lfloor \lg (n/m) \rfloor / 2) 2^{- \lfloor \lg (m / \epsilon) \rfloor}$.
%% $2^{- \lfloor \lg (m / \epsilon) \rfloor} < 2 (\epsilon / m)$, so the total fpp is less than $\epsilon (2 + \lfloor \lg (n/m) \rfloor)$.
%% This matches or improves the result of Pagh et al. when $2 + \lfloor \lg (n/m) \rfloor \in \lg^{O(1)} |U|$.

%% For the rest of this discussion, we will assume $|U| \geq  n/\epsilon$.

%% Otherwise, if $\lg |U| < \lfloor \lg (m / \epsilon) \rfloor$, then the sum is

%% $$m2^{-\lg |U|} + (m/2) \sum_{j=1}^{\lfloor \lg (n/m) \rfloor} 2^{-\lg |U| + j}$$
%% $$m2^{-\lg |U|} (1 + (1/2) \sum_{j=1}^{\lfloor \lg (n/m) \rfloor} 2^{j})$$
%% $$m2^{-\lg |U|} (1 + (1/2) (2^{\lfloor \lg (n/m) \rfloor} -1))$$
%% $$m2^{-\lg |U|} (1 + (2^{\lfloor \lg (n/m) \rfloor - 1} -1))$$
%% $$m2^{-\lg |U|} (2^{\lfloor \lg (n/m) \rfloor - 1})$$
%% $$m(2^{\lfloor \lg (n/m) \rfloor - 1 - \lg |U|})$$
%% $$2^{\lg m + \lfloor \lg (n/m) \rfloor - 1 - \lg |U|}$$
%% $$< 2^{\lg m + \lg (n/m) - 1 - \lg |U|}$$
%% $$2^{\lg n - 1 - \lg |U|}$$

%% Finally, if $\lfloor \lg (m / \epsilon) \rfloor \leq \lg |U| <  \lfloor \lg (n/m) \rfloor + \lfloor \lg(m/\epsilon) \rfloor$, the sum is

%% $$m2^{- \lfloor \lg (m / \epsilon) \rfloor} + (m/2) \left ( \sum_{j=1}^{\lg |U| - \lfloor \lg (m/\epsilon) \rfloor} 2^{- \lfloor \lg (m / \epsilon) \rfloor}
%% + \sum_{j= \lg |U| - \lfloor \lg (m/\epsilon) \rfloor + 1}^{\lfloor \lg (n/m) \rfloor} 2^{-\lg |U| + j} \right)$$
%% $$m2^{- \lfloor \lg (m / \epsilon) \rfloor} + (m/2) \left ( (\lg |U| - \lfloor \lg (m/\epsilon) \rfloor) 2^{- \lfloor \lg (m / \epsilon) \rfloor}
%% + 2^{-\lg |U| + \lfloor \lg (n/m) \rfloor + 1} - 2^{-\lfloor \lg (m/\epsilon) \rfloor + 1} \right)$$

\subsection{Implementing tail filters}

The tail filter implementation tracks, in addition to $m$, $\epsilon$, and the cohort number, two data structures.

%One structure stores all bitstrings in $[F]$ that have length greater than $\lfloor \lg n \rfloor$ in a map from $[2^{\lfloor \lg (m/\epsilon) \rfloor}]$ to bitstrings of length up to $\lfloor \lg(n/m) \rfloor$, embedded in $[2^{\lfloor \lg(n/m) \rfloor + 1}]$ as described earlier.

One structure stores all bitstrings in $F$ that have length greater than or equal to $\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor$.
They are stored in a map in which the keys are values from $[2^{\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor}]$ and the values are bitstrings of length up to $\lfloor \lg (m/\epsilon) \rfloor - \lfloor \lg m \rfloor$, embedded in bitstrings of length exactly $\lfloor \lg (m/\epsilon) \rfloor - \lfloor \lg m \rfloor + 1$ as described earlier.
Using a quotient DySECT dictionary, this can be stored in $(1 + o(1))(\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor)(\lfloor \lg (m/\epsilon) \rfloor - \lfloor \lg m \rfloor + 1) \leq (1+o(1))n(\lg (1/\epsilon) + O(1))$ bits of space.

%% The map is stored in a quotient DySECT dictionary.
%% If $ \lfloor \lg(n/m) \rfloor + \lfloor \lg m \rfloor < \lfloor \lg (m/\epsilon) \rfloor$, then all bitstrings are longer than $\lfloor \lg(n/m) \rfloor + \lfloor \lg m \rfloor$.
%% In this case, the quotient DySECT dictionary can store the $n$ bitstrings in $(1 + o(1)) n (O(1) + \lg (m/\epsilon) \rfloor - \lfloor \lg m \rfloor)$ bits of space.
%% This is also $(1 + o(1)) n (O(1) - \lg \epsilon)$.

%% Otherwise, the number of bitstrings shorter than $\lfloor \lg(n/m) \rfloor + \lfloor \lg m \rfloor + 1$ is $m2^{\lfloor \lg(n/m) \rfloor + \lfloor \lg m \rfloor - \lfloor \lg (m/\epsilon)\rfloor}$, which is at least $m2^{\lg(n/m) + \lg m -  \lg (m/\epsilon) - 2}= m2^{\lg (n\epsilon/m) - 2} = n\epsilon/4$.




%% Otherwise, the number of bitstrings longer than $\lfloor \lg(n/m) \rfloor + \lfloor \lg m \rfloor$ is

%% $$n - m2^{\lfloor \lg (n/m) \rfloor} + \sum_{j=1 + \lfloor \lg(n/m) \rfloor + \lfloor \lg m \rfloor - \lfloor \lg (m/\epsilon) \rfloor}^{\lfloor \lg (n/m) \rfloor - 1} m2^{j-1}$$
%% $$n - m2^{\lfloor \lg (n/m) \rfloor} + m2^{\lfloor \lg (n/m) \rfloor - 1} - m2^{\lfloor \lg(n/m) \rfloor + \lfloor \lg m \rfloor - \lfloor \lg (m/\epsilon) \rfloor}$$
%% $$m(n/m) - m2^{\lfloor \lg (n/m) \rfloor} + m\left(2^{\lfloor \lg (n/m) \rfloor - 1} - 2^{\lfloor \lg(n/m) \rfloor + \lfloor \lg m \rfloor - \lfloor \lg (m/\epsilon) \rfloor}\right)$$
%% $$m2^{\lg (n/m)} - m2^{\lfloor \lg (n/m) \rfloor} + m\left(2^{\lfloor \lg (n/m) \rfloor - 1} - 2^{\lfloor \lg(n/m) \rfloor + \lfloor \lg m \rfloor - \lfloor \lg (m/\epsilon) \rfloor}\right)$$
%% $$m2^{\lfloor \lg (n/m) \rfloor}\left(2^{\lg (n/m) - \lfloor \lg (n/m) \rfloor} - 1 + 2^{- 1} - 2^{\lfloor \lg m \rfloor - \lfloor \lg (m/\epsilon) \rfloor}\right)$$
%% $$m2^{\lfloor \lg (n/m) \rfloor}\left(2^{\lg (n/m) - \lfloor \lg (n/m) \rfloor} - 1 + 2^{- 1} - 2^{\lfloor \lg m \rfloor - \lfloor \lg (m/\epsilon) \rfloor}\right)$$



%% $$m\left(2^{\lg(n/m)} - 2^{\lfloor \lg (n/m) \rfloor} + 2^{\lfloor \lg (n/m) \rfloor - 1} - 2^{\lfloor \lg n \rfloor - \lfloor \lg (m/\epsilon) \rfloor}\right)$$

%% which is strictly between $n/4$ and $n/2$.
%% The same space bound as above, applies: $(1 + o(1)) n (O(1) - \lg \epsilon)$ bits.

The second structure is present if there are any bitstrings shorter than $\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor$.
Those are embedded in a bitset of length $2^{\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor - 1}$ as follows:
each slot in the bitset is interpreted as a bitstring $s$ of length exactly $\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor - 1$, and is set to {\bf true} if and only if there is any bitstring in $F$ that is a prefix of it.
Note that if there is any bitstring $x \in F$ that is a prefix of a bitstring of length exactly $\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor - 1$, then $x$ has length at most $\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor - 1$.

To perform {\bf lookup$(x)$}, both parts of the tail filter are consulted.
In the dictionary part, the first $\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor$ bits of $x$ are looked up in the map.
If one or more items in the dictionary has that key, each value is inspected to see if it is a prefix of the next $\lfloor \lg(m/\epsilon) \rfloor - \lfloor \lg m \rfloor$ bits of $x$.
If any do, then {\bf lookup} returns {\bf true}.
Otherwise, the bit in the bitset at the location that corresponds to the first $\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor - 1$ bits of $x$ is returned.

To perform {\bf insert$(x)$} on a structure in which cohort $\lfloor \lg (n/m) \rfloor$ is not full, $x$ is inserted into the dictionary: the key is the first $\lfloor \lg (n/m) \rfloor + \lfloor \lg m \rfloor$ bits of $x$ and the value is the next $1 + \lfloor \lg (m/\epsilon) \rfloor - \lfloor \lg m \rfloor$ bits.
If the cohort is full, the tail filter has to be rewritten.
First, the bitset is doubled in size.
Slot $2i + j$ in the new bitset, where $j < 2$, is set to equal slot $i$ in the old bitset.
Second, values from the dictionary with empty tails must be inserted into the bitset.
Finally, the dictionary is rewritten by adding an extra bit to the key portion of each key-value pair, pulled from the value portion.

%is used to represent all bitstrings of length less than or equal to $\lfloor \lg n \rfloor$.
%(This is all bitstrings inserted in epochs $0$ through $\lfloor \lg n \rfloor - \lfloor \lg (m / \epsilon) \rfloor$, inclusive)
%The bitset is initialized with all bits set to $0$.
%Each bitstring $x$ of length $j$ is then represented by storing a $1$ in all positions $\{x t + k : k \in [t]\}$, where $t$ is  $2^{\lfloor \lg n \rfloor - j}$.
%In other words, the locations corresponding to each bitstring of length $\lfloor \lg n \rfloor$ that has $x$ as a prefix are set to $1$.


%% $$n/4 < m\left(2^{\lg(n/m)} - 2^{\lfloor \lg (n/m) \rfloor} + 2^{\lfloor \lg (n/m) \rfloor - 1} - 2^{\lfloor \lg n \rfloor - \lfloor \lg (m/\epsilon) \rfloor}\right) < n/2$$

%% $$n - m \left(2^{\lfloor \lg (n/m) \rfloor} - \sum_{j=1+\lfloor \lg n \rfloor - \lfloor \lg (m/\epsilon) \rfloor}^{\lfloor \lg (n/m) \rfloor - 1} 2^{j-1}\right)$$
%% $$n - m \left(2^{\lfloor \lg (n/m) \rfloor} - \left( 2^{\lfloor \lg (n/m) \rfloor - 1} - 2^{\lfloor \lg n \rfloor - \lfloor \lg (m/\epsilon) \rfloor}\right)\right)$$
%% $$n - m \left(2^{\lfloor \lg (n/m) \rfloor} - 2^{\lfloor \lg (n/m) \rfloor - 1} + 2^{\lfloor \lg n \rfloor - \lfloor \lg (m/\epsilon) \rfloor}\right)$$
%% $$n - m \left(2^{\lfloor \lg (n/m) \rfloor - 1} + 2^{\lfloor \lg n \rfloor - \lfloor \lg (m/\epsilon) \rfloor}\right)$$

%% In this case, the dictionary uses $(1 + o(1)) n (O(1) + \lfloor \lg(n/m) \rfloor)$ space

%% There are $n - m  2^{\lfloor \lg n \rfloor - \lfloor \lg (m / \epsilon) \rfloor}$ of these.
%% They are embedded in the set $[2^{\lfloor \lg(n/m) \rfloor + \lfloor \lg (m / \epsilon) \rfloor + 1}]$, using the embedding described in the introduction.
%% These are stored using the quotient DySECT dictionary, using less than $(1 + o(1)) p (O(1) + \lceil \lg q \rceil - \lfloor \lg p \rfloor)$, where $p = n - m  2^{\lfloor \lg n \rfloor - \lfloor \lg (m / \epsilon) \rfloor}$ and $q = 2^{\lfloor \lg(n/m) \rfloor + \lfloor \lg (m / \epsilon) \rfloor + 1}$.
%% $\lfloor \lg p \rfloor > \lg n - 1$, and $\lceil \lg q \rceil < O(1) + \lg n - \lg \epsilon$, so the total space usage is less than $(1 + o(1)) n (O(1) - \lg \epsilon)$.
%The constant $8$ is rather loose and can be improved with a tighter analysis.


%% A tail filter is implemented in two structures.


%% Since this bitset is only used for epochs that are not the current one, {\bf insert} does not need to operate on this part of the structure.
%% {\bf lookup$(x)$} takes $O(1)$ time, consisting only of checking the bit at the position corresponding to the first $\lfloor \lg n \rfloor$ bits of $x$.


%% When an epoch ends, the ...

%% Combined with the bitset, this makes the total space usage $(1 + \iota) n \lg (1/\epsilon) + O(n)$ bits.
%% Since the fpp is $\epsilon (2 + \lfloor \lg (n/m) \rfloor)$, attaining a specific fixed fpp of $\delta$ uses, in the notation of Pagh et al., $(1 + o(1)) n (\lg (1/\epsilon) + \lg \lg n) + O(n)$, improving on $(1 + o(1)) n (\lg \epsilon) + O(n \lg \lg n)$.
%% Careful accounting might indicate their bound is actually as high as $O(n (\lg (1/\epsilon) + \lg \lg |U|))$.

\subsection{Equivalence of the implementation and the abstract semantics}

\section{Differences from Pagh et al.}

Doesn't need to double the space when full.

An asymptotically reduced upper bound on the space.

Now oblivious: don't need to know maximum filter size ahead of time.

\bibliography{main}{}
\bibliographystyle{alpha}
\end{document}

%%  LocalWords:  AMQ lookup bitstring bitstrings fpp AMQ's pre DySECT
%%  LocalWords:  quotienting Pagh et al bitset wlog
